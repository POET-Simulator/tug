#include "../include/diffusion/BTCSDiffusion.hpp"
#include "../include/diffusion/BoundaryCondition.hpp"
#include <algorithm> // for copy, max
#include <cmath>
#include <iomanip>
#include <iostream> // for std
#include <vector>   // for vector
#include <Rcpp.h>

using namespace std;
using namespace Diffusion;
using namespace Rcpp;
//using namespace Eigen;

// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::plugins("cpp11")]]
// [[Rcpp::export]]
std::vector<double> & diff1D(int n,
                             double length,
                             std::vector<double> & field,
                             std::vector<double> & alpha,
                             double timestep,
                             double bc_left,
                             double bc_right,
                             int iterations) {
    // dimension of grid
    int dim = 1;
    
    // create input + diffusion coefficients for each grid cell
    // std::vector<double> alpha(n, 1 * pow(10, -1));
    // std::vector<double> field(n, 1 * std::pow(10, -6));
    std::vector<boundary_condition> bc(n, {0,0});
    
    // create instance of diffusion module
    BTCSDiffusion diffu(dim);
    
    diffu.setXDimensions(length, n);
    
    // set the boundary condition for the left ghost cell to dirichlet
    bc[0] = {Diffusion::BC_CONSTANT, bc_left};
    bc[n-1] = {Diffusion::BC_CONSTANT, bc_right};
    
    // set timestep for simulation to 1 second
    diffu.setTimestep(timestep);
    
    //cout << setprecision(12);
    
    // loop 100 times
    // output is currently generated by the method itself
    for (int i = 0; i < iterations; i++) {
        diffu.simulate(field.data(), alpha.data(), bc.data());
    }

    // for (auto & cell : field) {
    //     Rcout << cell << "\n";
    // }
    
    return(field);
}
