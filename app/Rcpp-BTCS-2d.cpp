#include "../src/BTCSDiffusion.hpp" // for BTCSDiffusion, BTCSDiffusion::BC_DIRICHLET
#include "../src/BoundaryCondition.hpp"
#include <algorithm> // for copy, max
#include <cmath>
#include <iomanip>
#include <iostream> // for std
#include <vector>   // for vector
#include <Rcpp.h>

using namespace std;
using namespace Diffusion;
using namespace Rcpp;
//using namespace Eigen;

// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::plugins("cpp11")]]
// [[Rcpp::export]]
std::vector<double> & diff2D(int nx,
                             int ny,
                             double lenx,
                             double leny,
                             std::vector<double> & field,
                             std::vector<double> & alpha,
                             double timestep,
                             int iterations)
{
    // problem dimensionality
    int dim = 2;
    // total number of grid cells
    int n = nx*ny;
    
    std::vector<boundary_condition> bc(n, {0,0});
    
    // create instance of diffusion module
    BTCSDiffusion diffu(dim);
    
    diffu.setXDimensions(lenx, nx);
    diffu.setXDimensions(leny, ny);
    
    // set the boundary condition for the left ghost cell to dirichlet
    // bc[0] = {Diffusion::BC_CONSTANT, bc_left};
    // bc[n-1] = {Diffusion::BC_CONSTANT, bc_right};
    
    // set timestep for simulation to 1 second
    diffu.setTimestep(timestep);
    
    //cout << setprecision(12);
    
    // loop 100 times
    // output is currently generated by the method itself
    for (int i = 0; i < iterations; i++) {
        diffu.simulate(field.data(), alpha.data(), bc.data());
    }

    // for (auto & cell : field) {
    //     Rcout << cell << "\n";
    // }
    
    return(field);
}
