#include "diffusion/BTCSBoundaryCondition.hpp"
#include <diffusion/BTCSDiffusion.hpp>

#include <iomanip>
#include <iostream> // for std
#include <vector>   // for vector
using namespace std;

using namespace Diffusion;

int main(int argc, char *argv[]) {

  // dimension of grid
  int dim = 1;

  int n = 20;

  // create input + diffusion coefficients for each grid cell
  std::vector<double> alpha(n, 1e-1);
  std::vector<double> field(n, 1e-6);

  BTCSBoundaryCondition bc;

  // create instance of diffusion module
  BTCSDiffusion diffu(dim);

  diffu.setXDimensions(1, n);

  // set the boundary condition for the left ghost cell to dirichlet
  bc(BC_SIDE_LEFT) = {BC_TYPE_CONSTANT, 5e-6};
  // bc[0] = {Diffusion::BC_CONSTANT, 5e-6};
  // diffu.setBoundaryCondition(1, 0, BTCSDiffusion::BC_CONSTANT,
  //                            5. * std::pow(10, -6));

  // set timestep for simulation to 1 second
  diffu.setTimestep(1.);

  cout << setprecision(12);

  // loop 100 times
  // output is currently generated by the method itself
  for (int i = 0; i < 100; i++) {
    diffu.simulate(field.data(), alpha.data(), bc);

    cout << "Iteration: " << i << "\n\n";

    for (auto &cell : field) {
      cout << cell << "\n";
    }

    cout << "\n" << endl;
  }

  return 0;
}
